{"/home/travis/build/npmtest/node-npmtest-stylint/test.js":"/* istanbul instrument in package npmtest_stylint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylint/lib.npmtest_stylint.js":"/* istanbul instrument in package npmtest_stylint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stylint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stylint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stylint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stylint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stylint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stylint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stylint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_stylint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stylint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_stylint.__dirname + '/lib.npmtest_stylint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/index.js":"'use strict'\n\n// our stampit modules\nvar stampit = require( 'stampit' )\nvar fs = require( 'fs' )\n\n// let there be light ( * )\n// basically, with stampit we take a bunch of different objects\n// and methods and compose them into one mega object, the app\n// appropriately namespaced, with methods on the prototype,\n// and `this` set consistently (ie, available throughout the app)\n//\n// basic app flow below\n// init() -> read() -> parse() -> lint() -> done()\n// init() -> watch() -> read() -> parse() -> lint() -> done()\n\n\n/**\n * main stylint kickoff function\n * @param {string} path   [custom path if used programmatically]\n * @param {object} config [config if used programmatically]\n * @param {function} [callback] [a callback called just before exiting the process if not watching]\n * @return {Object} [the composed stylint object]\n */\nvar Stylint = function( path, config, callback ) {\n\treturn stampit().compose(\n\t\trequire( './src/core/' ),\n\t\trequire( './src/checks/' ),\n\t\trequire( './src/state/' ),\n\t\tstampit().enclose( function() {\n\t\t\tvar pkg = null\n\t\t\ttry {\n\t\t\t\tpkg = require( process.cwd() + '/package.json' )\n\t\t\t}\n\t\t\tcatch ( err ) {\n\t\t\t\t// no output\n\t\t\t}\n\n\t\t\t// set safe path defaults\n\t\t\tif ( typeof path === 'undefined' ) {\n\t\t\t\tthis.state.path = './'\n\t\t\t}\n\t\t\telse if ( path instanceof Array || typeof path === 'string' ) {\n\t\t\t\tthis.state.path = path\n\t\t\t}\n\n\t\t\t// look for a stylintignore array\n\t\t\t// for ignoring specific files\n\t\t\t// first look in package.json\n\t\t\t// then look for .stylintignore in the main dir\n\t\t\tif ( pkg !== null &&\n\t\t\t\t\ttypeof pkg.stylintignore !== 'undefined' &&\n\t\t\t\t\tpkg.stylintignore instanceof Array ) {\n\t\t\t\tthis.state.exclude = pkg.stylintignore\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tvar stylintIgnore = fs.readFileSync( process.cwd() + '/.stylintignore' )\n\t\t\t\t\tthis.state.exclude = stylintIgnore\n\t\t\t\t\t\t.toString()\n\t\t\t\t\t\t.split( '\\n' )\n\t\t\t\t\t\t.filter( function( d ) {\n\t\t\t\t\t\t\treturn d\n\t\t\t\t\t\t} )\n\t\t\t\t}\n\t\t\t\tcatch ( err ) {\n\t\t\t\t\t// do no-thing\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.customConfig = typeof config === 'object' ? config : false\n\t\t\tthis.callback = callback || function() {}\n\t\t} ).enclose( require( './src/core/init' ) )\n\t)\n}\n\nmodule.exports = Stylint\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/blocks.js":"'use strict'\n\nvar eqEndRe = /=$|=\\s$/\n\n\n/**\n * @description depending on settings, enforce of disallow @block when defining block vars\n * @param {string} [line] curr line being linted\n * @returns {boolean | undefined} true if @block found, false if not, undefined if we skip\n */\nvar blocks = function( line ) {\n\tif ( line.indexOf( '=' ) === -1 ) { return }\n\n\tvar block\n\tvar index = line.indexOf( '@block' )\n\n\t// if = ends the line and not a block var or hash\n\tif ( index === -1 && eqEndRe.test( line ) ) {\n\t\tblock = false\n\t}\n\telse if ( index !== -1 ) {\n\t\tblock = true\n\t}\n\n\tif ( this.state.conf === 'always' && block === false ) {\n\t\tthis.msg( 'block variables must include @block', line.length )\n\t}\n\telse if ( this.state.conf === 'never' && block === true ) {\n\t\tthis.msg( '@block is not allowed', index )\n\t}\n\n\treturn block\n}\n\nmodule.exports = blocks\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/brackets.js":"'use strict'\n\nvar ignoreRe = /\\(.*\\)|@extend|\\(|if|for(?!\\w)|else|return|@block|@media|@import|@require|,$/\nvar stripRe = /(?=\\S)\\[\\S+\\]|(\\.|#)\\w+/\nvar equalsRe = /( =|\\?=|\\+=|-=)+/\nvar validJSON = require( '../data/valid.json' )\n\n\n/**\n * @description check for brackets\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if bracket found, false if not\n */\nvar brackets = function( line ) {\n\t// in order if:\n\t// 1 in hash or css block\n\t// 2 variable or hash or block\n\t// 3 mixin\n\t// 4 .selector,\n\tif ( this.state.hashOrCSS ||\n\t\tline.trim().length === 0 ||\n\t\tequalsRe.test( line ) ||\n\t\tignoreRe.test( line ) ) {\n\t\treturn\n\t}\n\n\tvar arr = ['hint']\n\tvar isCSS = false\n\tvar isMixin = false\n\tvar bracket = false\n\n\tif ( this.state.conf === 'never' ) {\n\t\t// ex: $hash = { is ok but .class = { is not\n\t\tif ( line.indexOf( '{' ) !== -1 &&\n\t\t\tline.indexOf( '=' ) === -1 &&\n\t\t\tline.indexOf( '}' ) === -1 ) {\n\t\t\tbracket = true\n\t\t}\n\t\t// ex: } is okay if ending a hash. otherwise it is NOT okay\n\t\t// one liners are lame but ok ( check for = { )\n\t\telse if ( line.indexOf( '}' ) !== -1 && line.indexOf( '{' ) === -1 ) {\n\t\t\tbracket = true\n\t\t}\n\t}\n\telse if ( this.state.conf === 'always' ) {\n\n\t\tif ( bracket === false ) {\n\t\t\tarr = this.splitAndStrip( new RegExp( /[\\s\\t,:]/ ), line )\n\n\t\t\tif ( typeof arr[0] !== 'undefined' ) {\n\t\t\t\tarr[0] = arr[0].replace( stripRe, '' ).trim()\n\n\t\t\t\tisCSS = validJSON.css.some( function( css ) {\n\t\t\t\t\treturn arr[0] === css || this.checkPrefix( arr[0], css, validJSON )\n\t\t\t\t}.bind( this ) )\n\n\t\t\t\tisMixin = this.cache.customProperties.some( function( mixin ) {\n\t\t\t\t\treturn arr[0] === mixin\n\t\t\t\t} )\n\t\t\t}\n\n\t\t\t// basically, we don't care about properties like margin or padding\n\t\t\tif ( line.trim().indexOf( '}' ) !== -1 || isCSS || isMixin ) { return }\n\n\t\t\tif ( line.indexOf( '{' ) !== -1 ) {\n\t\t\t\tbracket = true\n\t\t\t\tthis.state.openBracket = true\n\t\t\t}\n\t\t\t// ex: } is okay if ending a hash. otherwise it is NOT okay\n\t\t\telse if ( line.indexOf( '}' ) !== -1 && this.state.openBracket ) {\n\t\t\t\tbracket = true\n\t\t\t\tthis.state.openBracket = false\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( this.state.conf === 'never' && bracket === true ) {\n\t\tthis.msg( 'unnecessary bracket', line.indexOf( '{' ) )\n\t}\n\telse if ( this.state.conf === 'always' && bracket === false ) {\n\t\tthis.msg( 'always use brackets when defining selectors', line.length )\n\t}\n\n\treturn bracket\n}\n\nmodule.exports = brackets\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/colons.js":"'use strict'\n\nvar validJSON = require( '../data/valid.json' )\n// we only want to check colons on properties/values\nvar ignoreRe = /( ^[&$=#>.]|\\.[a-zA-Z]|#[a-zA-Z]| \\+ | , | = | ~ | > | &| {|}|\\(|if|for(?!\\w)|else|return|@block|@media|@import|@extend|@require|,$)/m\n\n\n/**\n * @description check for colons\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if colon found, false if not\n */\nvar colons = function( line ) {\n\tif ( ignoreRe.test( line ) || this.state.context === 0 ) { return }\n\n\tvar colon\n\tvar hasPseudo = false\n\tvar hasScope = false\n\tvar arr = this.splitAndStrip( new RegExp( /\\s/ ), line )\n\n\tif ( this.state.conf === 'always' &&\n\t\tarr.length > 1 &&\n\t\tarr[0].indexOf( ':' ) === -1 &&\n\t\tarr[0].indexOf( ',' ) === -1 ) {\n\t\tcolon = false\n\t}\n\t// : is allowed in hashes\n\telse if ( !this.state.hash &&\n\t\tthis.state.conf === 'never' &&\n\t\tline.indexOf( ':' ) !== -1 ) {\n\n\t\t// check for pseudo selector\n\t\thasPseudo = validJSON.pseudo.some( function( val ) {\n\t\t\treturn line.indexOf( val ) !== -1\n\t\t} )\n\n\t\t// check for scope selector\n\t\thasScope = validJSON.scope.some( function( val ) {\n\t\t\treturn line.indexOf( val ) !== -1\n\t\t} )\n\n\t\tif ( !hasPseudo && !hasScope ) {\n\t\t\tcolon = true\n\t\t}\n\t}\n\n\tif ( this.state.conf === 'always' && colon === false ) {\n\t\tthis.msg( 'missing colon between property and value', arr[0].length )\n\t}\n\telse if ( this.state.conf === 'never' && colon === true ) {\n\t\tthis.msg( 'unnecessary colon found', line.indexOf( ':' ) )\n\t}\n\n\treturn colon\n}\n\nmodule.exports = colons\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/colors.js":"'use strict'\n\nvar hexRe = /#(?:[0-9a-f]{3}){1,2}/im\nvar ignoreRe = /^\\s*(?:#|.*=.*)/\n\n\n/**\n * @description if we disallowed hex colors, check for them and return true if found\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if hex color found, false if not\n */\nvar colors = function( line ) {\n\tif ( ignoreRe.test( line ) || this.state.root ) { return }\n\n\tvar hex = false\n\tvar match = hexRe.exec( line )\n\n\t// so basically if we're using #hex colors outside of a var declaration\n\tif ( match !== null ) {\n\t\thex = true\n\t}\n\n\tif ( hex === true ) {\n\t\tthis.msg( 'hexidecimal color should be a variable', match.index )\n\t}\n\n\treturn hex\n}\n\nmodule.exports = colors\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/commaSpace.js":"'use strict'\n\n// if , is present on line and its not followed by a space\nvar noSpaceRe = /,\\S/\nvar withSpaceRe = /,\\s/\nvar removeQuotesRe = /([\"'])(?:(?=(\\\\?))\\2.)*?\\1/g\n\n/**\n * @description if set to always, enforces spaces after commas. if set to never, disallows spaces\n * @param {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @returns {boolean} true if space missing, false if not\n */\nvar commaSpace = function( line, origLine ) {\n\t// conditions where testing isn't needed.\n\t// 1: no comma on line at all\n\t// 2: comma ends the line, as in a list\n\t// 3: comma is\n\tif ( origLine.indexOf( ',' ) === -1 ||\n\t\torigLine.trim().indexOf( ',' ) === origLine.length - 1 ) {\n\t\treturn\n\t}\n\n\t// just strip content between quotes, leave rest of syntax intact\n\t// this is so we don't get false positives with , in strings\n\tvar trimmedLine = origLine.replace( removeQuotesRe, '\"\"' ).trim()\n\n\tvar noSpace = noSpaceRe.exec( trimmedLine )\n\tvar hasSpace = withSpaceRe.exec( trimmedLine )\n\n\t// if spaces should be follow commas, but there is no space on the line\n\tif ( this.state.conf === 'always' && noSpace ) {\n\t\tthis.msg( 'commas must be followed by a space for readability', noSpace.index )\n\t}\n\t// if spaces should not be followed by a comma, but there are spaces anyway\n\telse if ( this.state.conf === 'never' && hasSpace ) {\n\t\tthis.msg( 'spaces after commas are not allowed', hasSpace.index )\n\t}\n\n\treturn !!( noSpace && !hasSpace )\n}\n\nmodule.exports = commaSpace\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/commentSpace.js":"'use strict'\n\nvar commentRe = /\\/\\/ /\n\n\n/**\n * @description // check for space after line comment\n * @param  {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @returns {boolean} true if comment found, false if not\n */\nvar commentSpace = function( line, origLine ) {\n\tif ( !this.state.hasComment ) { return }\n\n\tvar spaceAfterComment = false\n\tvar comment = this.cache.comment\n\tvar index = origLine.indexOf( comment )\n\n\t// check for space after comment on it's own line,\n\t// if no space, return warning\n\tif ( commentRe.test( comment ) ) {\n\t\tspaceAfterComment = true\n\t}\n\n\tvar emptyComment = /\\/\\/$/.test( comment )\n\n\tif ( this.state.conf === 'always' && spaceAfterComment === false && !emptyComment ) {\n\t\tthis.msg( 'line comments require a space after //', index )\n\t}\n\telse if ( this.state.conf === 'never' && spaceAfterComment === true ) {\n\t\tthis.msg( 'spaces after line comments disallowed', index )\n\t}\n\n\treturn spaceAfterComment\n}\n\nmodule.exports = commentSpace\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/cssLiteral.js":"'use strict'\n\n\n/**\n * @description if we disallowed css literals, check for them and return true if found\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if @css found, false if not\n * @TODO do i still work with setState?\n */\nvar cssLiteral = function( line ) {\n\tif ( this.state.hashOrCSS ) { return }\n\tvar isCSSLiteral = false\n\tvar index = line.indexOf( '@css' )\n\n\tif ( index !== -1 ) {\n\t\tisCSSLiteral = true\n\t}\n\n\tif ( this.state.conf === 'never' && isCSSLiteral === true ) {\n\t\tthis.msg( 'css literals are disallowed', index )\n\t}\n\n\treturn isCSSLiteral\n}\n\nmodule.exports = cssLiteral\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/depthLimit.js":"'use strict'\n\n// check if using selector before we count depth\n// definitely not the best way to do this,\nvar ampRe = /^(&|\\/{1}|\\.\\.\\/|~\\/)/\n\n\n/**\n * @description check nesting depth\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if nesting is too deep, false if not\n * @todo this is kinda not 100% reliable in it's current form, also could be refactors\n */\nvar depthLimit = function( line ) {\n\tvar context = this.state.context\n\tvar badNesting = false\n\tvar limit = this.config.depthLimit ? this.config.depthLimit : 5\n\n\t// trim string and check if line starts with &\n\t// reduce context in that case\n\t// @TODO not really ideal\n\tif ( ampRe.test( line.trim() ) ) {\n\t\tcontext -= 1\n\t}\n\n\tif ( context > limit ) {\n\t\tbadNesting = true\n\t}\n\n\tif ( badNesting === true ) {\n\t\tthis.msg( 'selector depth greater than ' + limit )\n\t}\n\n\treturn badNesting\n}\n\nmodule.exports = depthLimit\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/duplicates.js":"'use strict'\n\nvar ignoreRe = /^{|[,}]|(:after|:active|:before|@import|@require|@extend|@media|:hover|@font-face|src)|,$/\nvar lastFile = ''\n\n\n/**\n * @description check that selector properties are sorted alphabetically\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if dupe found, false if not\n */\nvar duplicates = function( line ) {\n\tvar arr = this.splitAndStrip( new RegExp( /[\\s\\t]/ ), line )\n\tvar dupe = false\n\tvar dupeIndex\n\tvar origFile\n\n\t// if root check not global, obliterate cache on each new file\n\tif ( !this.config.globalDupe &&\n\t\tlastFile !== this.cache.file ) {\n\t\tthis.cache.sCache = {}\n\t\tlastFile = this.cache.file\n\t}\n\n\t// if cache for curr context doesn't exist yet (or was obliterated), make one\n\tif ( typeof this.cache.sCache[ this.state.context ] === 'undefined' ) {\n\t\tthis.cache.sCache[ this.state.context ] = []\n\t}\n\n\t// if context changes, reset arrays except root\n\t// basically, root can persist across files potentially\n\t// caches above root only persist as long as they are within their context\n\tif ( this.state.context !== this.state.prevContext ) {\n\t\tObject.keys( this.cache.sCache ).forEach( function( val ) {\n\t\t\t// string cause key\n\t\t\tif ( val === '0' ) { return }\n\t\t\tthis.cache.sCache[val] = []\n\t\t}.bind( this ) )\n\t}\n\n\t// if not in a list\n\t// and not ignored syntax\n\t// and property exists in the array already\n\t// then dupe\n\tif ( line.indexOf( ',' ) === -1 &&\n\t\tthis.cache.prevLine.indexOf( ',' ) === -1 &&\n\t\t!ignoreRe.test( line ) ) {\n\n\t\t// -1 if no dupe found\n\t\tdupeIndex = this.cache.sCache[this.state.context].indexOf( arr[0] )\n\n\t\t// if match found at right context, is dupe\n\t\tif ( dupeIndex !== -1 ) {\n\t\t\tdupe = true\n\t\t}\n\n\t\t// push selector (and file name) to cache\n\t\tthis.cache.sCache[this.state.context].push( arr[0], this.cache.file )\n\t}\n\n\tif ( dupe === true ) {\n\t\t// location of original selector use if global dupe on\n\t\torigFile = this.cache.sCache[this.state.context][dupeIndex + 1]\n\n\t\t// this.msg( 'duplicate property or selector, consider merging' )\n\t\tif ( !this.config.globalDupe ) {\n\t\t\tthis.msg(\n\t\t\t\t'duplicate property or selector, consider merging'\n\t\t\t)\n\t\t}\n\t\telse {\n\t\t\tthis.msg(\n\t\t\t\t'duplicate property or selector, consider merging\\nsee file: ' + origFile + ' for the original selector'\n\t\t\t)\n\t\t}\n\t}\n\n\treturn dupe\n}\n\nmodule.exports = duplicates\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/efficient.js":"'use strict'\n\nvar valueRe = /(margin|padding)+[:| ]/\n\n\n/**\n * @description check for 0 0 0 0 or 50px 0 50px 0 type mistakes\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if efficient, false if not\n */\nvar efficient = function( line ) {\n\t// line doesnt have margin or padding then there's nothin to do here\n\tif ( !valueRe.test( line ) ) { return }\n\n\tvar isEfficient = true\n\tvar arr = this.splitAndStrip( new RegExp( /[\\s\\t]/ ), line )\n\n\t// if margin or padding we run the tests\n\t// if line is potentially inefficient it needs to be at least this long\n\tif ( arr.length > 2 ) {\n\t\t// ex: margin 0 5px\n\t\tif ( arr.length === 3 ) {\n\t\t\t// ex margin 0 0\n\t\t\tif ( arr[1] === arr[2] ) {\n\t\t\t\tisEfficient = false\n\t\t\t}\n\t\t}\n\t\t// ex margin 0 5px 10px\n\t\telse if ( arr.length === 4 && arr[1] === arr[3] ) {\n\t\t\t// ex margin 0 5px 0\n\t\t\tisEfficient = false\n\t\t}\n\t\t// ex margin 0 50px 10px 7px\n\t\telse if ( arr.length === 5 ) {\n\t\t\t// ex margin 0 5px 0 5px or\n\t\t\tif ( arr[1] === arr[3] && arr[2] === arr[4] ||\n\t\t\t\tarr[1] !== arr[3] && arr[2] === arr[4] ) {\n\t\t\t\tisEfficient = false\n\t\t\t}\n\t\t}\n\t}\n\n\tvar index = line.indexOf( arr[1] )\n\n\tif ( this.state.conf === 'never' && isEfficient === true ) {\n\t\tthis.msg( 'the value on this line is too succinct', index )\n\t}\n\telse if ( this.state.conf === 'always' && isEfficient === false ) {\n\t\tthis.msg( 'the value on this line could be more succinct', index )\n\t}\n\n\treturn isEfficient\n}\n\nmodule.exports = efficient\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/extendPref.js":"'use strict'\n\n\n/**\n * @description check for specified extend preference\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if wrong style used, false if not\n */\nvar extendPref = function( line ) {\n\tif ( line.indexOf( '@extend' ) === -1 ) { return }\n\n\tvar extendIncorrect = false\n\n\t// prefer @extends to @extend\n\t// extremely petty, i know\n\tif ( this.state.conf === '@extends' && line.indexOf( '@extends ' ) === -1 ) {\n\t\textendIncorrect = true\n\t}\n\t// else @extend is your pref\n\telse if ( this.state.conf === '@extend' && line.indexOf( '@extend ' ) === -1 ) {\n\t\textendIncorrect = true\n\t}\n\n\tif ( extendIncorrect === true ) {\n\t\tthis.msg( 'please use ' + this.state.conf )\n\t}\n\n\treturn extendIncorrect\n}\n\nmodule.exports = extendPref\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/indentPref.js":"'use strict'\n\n\n/**\n * @description checks that the # of spaces used is consistent\n * @returns {boolean} true if # of spaces correct, false if not\n */\nvar indentPref = function() {\n\tvar spaces = this.state.conf\n\tvar context = this.state.context\n\n\tif ( typeof spaces !== 'number' ) { return }\n\n\tvar indentCorrect = true\n\n\tif ( context % 1 !== 0 ) {\n\t\tindentCorrect = false\n\t}\n\n\t// if spaces === 2 and context === 1.5 (meaning 1.5 levels... or 3 spaces)\n\t// then the index for the warning msg is 2 * 1.5, or 3 spaces\n\tvar index = spaces * context\n\n\tif ( indentCorrect === false ) {\n\t\tthis.msg( 'incorrect # of spaces for indent, use ' + spaces, index )\n\t}\n\n\treturn indentCorrect\n}\n\nmodule.exports = indentPref\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/leadingZero.js":"'use strict'\n\nvar decimalRe = /[^\\d+](0+\\.\\d+)|[\\s,\\(](\\.\\d+)/i\nvar leadZeroRe = /[^\\d+](0+\\.\\d+)/\nvar nonZeroRe = /[\\s,\\(](\\.\\d+)/\n\n\n/**\n * @description check for leading 0 on numbers ( 0.5 )\n * @param {string} [line] curr line being linted\n * @returns {boolean|undefined} true if mixed, false if not\n */\nvar leadingZero = function( line ) {\n\tif ( !decimalRe.test( line ) ) { return }\n\n\tvar leadZeroFound = leadZeroRe.exec( line )\n\tvar leadZeroMissing = nonZeroRe.exec( line )\n\n\tif ( this.state.conf === 'always' && leadZeroMissing ) {\n\t\tthis.msg( 'leading zeros for decimal points are required', leadZeroMissing.index )\n\t}\n\telse if ( this.state.conf === 'never' && leadZeroFound ) {\n\t\tthis.msg( 'leading zeros for decimal points are unnecessary', leadZeroFound.index )\n\t}\n\n\treturn leadZeroFound\n}\n\nmodule.exports = leadingZero\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/mixed.js":"'use strict'\n\n// was a tab used, at all\nvar tabs = /\\t/\n// check for 2 or more spaces (if hard tabs, shouldn't find anything)\nvar spaces = /( {2,})+/\n// don't throw false positives if line ends in comment\nvar trimRightRe = /( |\\t)+(\\/\\/)+.+$/gm\n\n\n/**\n * @description check for mixed spaces and tabs\n * @param {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @returns {boolean} true if mixed, false if not\n */\nvar mixed = function( line, origLine ) {\n\tvar trimRight = origLine.replace( trimRightRe, '' )\n\tvar isMixed = false\n\tvar indentPref = this.config.indentPref.expect || this.config.indentPref\n\tvar isNum = typeof indentPref === 'number'\n\n\t// regexp obj or null\n\tvar hasTabs = tabs.exec( trimRight )\n\tvar hasSpaces = spaces.exec( trimRight )\n\n\t// if this isnt set to false then we're indenting with spaces,\n\t// so check against tabs\n\tif ( isNum ) {\n\t\tif ( hasTabs ) {\n\t\t\tisMixed = true\n\t\t}\n\t}\n\t// else you're a hard tab believer (go you)\n\t// look for 2 or more spaces\n\telse if ( hasSpaces ) {\n\t\tisMixed = true\n\t}\n\n\tif ( isMixed === true ) {\n\t\tvar index = isNum ? hasTabs.index : hasSpaces.index\n\t\tthis.msg( 'mixed spaces and tabs', index )\n\t}\n\n\treturn isMixed\n}\n\nmodule.exports = mixed\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/namingConvention.js":"'use strict'\n\n// the alphabet, uppers\nvar upperRe = /[A-Z]+/m\n// BEM (http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/)\nvar bemRe = /^([$.#{:][${a-z]([-]?[${}a-z0-9]+)*(_{2}[${}a-z0-9]([-]?[${}a-z0-9]+)*)?((_[${}a-z0-9]([-]?[a-z0-9}]+)*){2})*)\\b/m\n// camelCase or CamelCase\nvar camelRe = /^[$#.{:]+([a-zA-Z]|[${}])+([a-z]|[${}])+(([.A-Z0-9])+[a-z ]+)+\\b/m\n\n\n/**\n * @description check for names-like-this vs namesLikeThis\n * or NamesLikeThis vs names_like_this or names-like__this-that\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if convention wrong, false if not\n */\nvar namingConvention = function( line ) {\n\tvar arr = this.splitAndStrip( ' ', line )\n\t// determine if line should be tested at all\n\tvar doWeTestRe = /^[${:]+/m\n\tvar badConvention = false\n\n\t// test a wider range if strict is true\n\tif ( this.config.namingConventionStrict === true ) {\n\t\tdoWeTestRe = /^[$#.{:]+/m\n\t}\n\n\t// only run checks if on a class, id, or variable\n\tif ( doWeTestRe.test( arr[0] ) && arr[0].indexOf( '::' ) === -1 ) {\n\t\t// if all lowercase we do nothing, if -, _ or uppercase found we check convention\n\t\tif ( upperRe.test( arr[0] ) ||\n\t\t\tarr[0].indexOf( '-' ) !== -1 ||\n\t\t\tarr[0].indexOf( '_' ) !== -1 ) {\n\n\t\t\t// check conventions\n\t\t\t// $varName\n\t\t\tif ( this.state.conf === 'camelCase' ) {\n\t\t\t\t// if no A-Z present, or - present, or _ present\n\t\t\t\tif ( arr[0].indexOf( '-' ) !== -1 ||\n\t\t\t\t\tarr[0].indexOf( '_' ) !== -1 ||\n\t\t\t\t\t!camelRe.test( arr[0] ) ) {\n\t\t\t\t\tbadConvention = true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// $var_name\n\t\t\telse if ( this.state.conf === 'lowercase_underscore' ) {\n\t\t\t\t// if no _ present, or - present, or A-Z present\n\t\t\t\tif ( arr[0].indexOf( '-' ) !== -1 ||\n\t\t\t\t\tarr[0].indexOf( '_' ) === -1 ||\n\t\t\t\t\tupperRe.test( arr[0] ) ) {\n\t\t\t\t\tbadConvention = true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// $var-name\n\t\t\telse if ( this.state.conf === 'lowercase-dash' ) {\n\t\t\t\t// if no - present, or _ present, or A-Z present\n\t\t\t\tif ( arr[0].indexOf( '-' ) === -1 ||\n\t\t\t\t\tarr[0].indexOf( '_' ) !== -1 ||\n\t\t\t\t\tupperRe.test( arr[0] ) ) {\n\t\t\t\t\tbadConvention = true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// $var__element\n\t\t\telse if ( this.state.conf === 'BEM' ) {\n\t\t\t\t// if A-Z or not following BEM specification\n\t\t\t\tif ( upperRe.test( arr[0] ) || !bemRe.test( arr[0] ) ) {\n\t\t\t\t\tbadConvention = true\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if not one of the defaults, assume custom regExp\n\t\t\telse if ( typeof this.state.conf === 'string' ) {\n\t\t\t\tvar conventionRe = new RegExp( this.state.conf, 'm' )\n\n\t\t\t\tif ( !conventionRe.test( arr[0] ) ) {\n\t\t\t\t\tbadConvention = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( badConvention === true ) {\n\t\tvar index = line.indexOf( arr[0] )\n\t\tthis.msg( 'preferred naming convention is ' + this.state.conf, index )\n\t}\n\n\treturn badConvention\n}\n\nmodule.exports = namingConvention\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/noImportant.js":"'use strict'\n\n\n/**\n * @description disallows use of !important\n * @param {string} [line] curr line being linted\n * @return {boolean} true if !important used, false if not\n */\nvar noImportant = function( line ) {\n\tvar important = false\n\tvar index = line.indexOf( '!important' )\n\n\t// return true if border|outline is followed by a 0\n\tif ( index !== -1 ) {\n\t\timportant = true\n\t}\n\n\tif ( important === true ) {\n\t\tthis.msg( '!important is disallowed', index )\n\t}\n\n\treturn important\n}\n\nmodule.exports = noImportant\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/none.js":"'use strict'\n\nvar zeroRe = /((border)|(outline))+(:|\\s)+0(?!-)/\nvar noneRe = /((border)|(outline))+(:|\\s)+(none)+(?!-)/\n\n\n/**\n * @description checks for border none or outline none\n * @param {string} [line] curr line being linted\n * @return {boolean} true if none used, false if not\n */\nvar none = function( line ) {\n\tif ( line.indexOf( 'border' ) === -1 &&\n\t\tline.indexOf( 'outline' ) === -1 ) {\n\t\treturn\n\t}\n\n\t// false if nothing wrong with line\n\t// true if problem found with line, regardless of config\n\tvar badSyntax = false\n\n\t// return true if border|outline is followed by a 0\n\t// enforce use of none\n\tif ( this.state.conf === 'always' &&\n\t\t\tzeroRe.test( line ) &&\n\t\t\t!noneRe.test( line ) ) {\n\t\tbadSyntax = true\n\t\tthis.msg( 'none is preferred over 0', line.indexOf( '0' ) )\n\t}\n\t// return true if border|outline is followed by none\n\t// enforce use of 0\n\telse if ( this.state.conf === 'never' &&\n\t\tnoneRe.test( line ) &&\n\t\t!zeroRe.test( line ) ) {\n\t\tbadSyntax = true\n\t\tthis.msg( '0 is preferred over none', line.indexOf( 'none' ) )\n\t}\n\n\treturn badSyntax\n}\n\nmodule.exports = none\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/parenSpace.js":"'use strict'\n\nvar parensRe = /\\(.+\\)/\nvar parensBeginWithSpaceRe = /\\(\\s+/\nvar parensEndWithSpaceRe = /\\s+\\)+/\nvar parensBeginWithNoSpaceRe = /\\(\\S+/\nvar parensEndWithNoSpaceRe = /\\S+\\)+/\n\n\n/**\n * @description checks for extra space when using parens\n * @param {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @return {boolean} true if placeholder used, false if not\n */\nvar parenSpace = function( line, origLine ) {\n\tif ( !parensRe.test( origLine ) ) { return }\n\n\tvar hasStartSpace = parensBeginWithSpaceRe.exec( origLine )\n\tvar hasEndSpace = parensEndWithSpaceRe.exec( origLine )\n\tvar index\n\tvar missingStartSpace\n\tvar missingEndSpace\n\n\tif ( this.state.conf === 'always' && ( !hasStartSpace || !hasEndSpace ) ) {\n\t\tmissingStartSpace = parensBeginWithNoSpaceRe.exec( origLine )\n\t\tmissingEndSpace = parensEndWithNoSpaceRe.exec( origLine )\n\t\tindex = missingStartSpace && missingStartSpace.index\n\n\t\tif ( !index && missingEndSpace ) {\n\t\t\tindex = missingEndSpace.index\n\t\t}\n\n\t\tthis.msg( '( param1, param2 ) is preferred over (param1, param2)', index )\n\t}\n\telse if ( this.state.conf === 'never' && ( hasStartSpace || hasEndSpace ) ) {\n\t\tindex = hasStartSpace && hasStartSpace.index\n\n\t\tif ( !index && hasEndSpace ) {\n\t\t\tindex = hasEndSpace.index\n\t\t}\n\n\t\tthis.msg( '(param1, param2) is preferred over ( param1, param2 )', index )\n\t}\n\n\treturn hasStartSpace && hasEndSpace\n}\n\nmodule.exports = parenSpace\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/placeholders.js":"'use strict'\n\nvar extendRe = /(@extend)+s?\\s/\n\n\n/**\n * @description check that @extend is only used with a $placeholderVar\n * @param {string} [line] curr line being linted\n * @return {boolean} true if placeholder used, false if not\n */\nvar placeholders = function( line ) {\n\tif ( line.indexOf( '@extend' ) === -1 ) { return }\n\n\tvar placeholder = false\n\n\t// stylus supports multiple, mixed extends and optional extends\n\t// so lets pull them out of the line and check individually\n\t// @extends .biz !optional, $extendable !optional =>\n\t// ['.biz !optional', '$extendable !optional']\n\tvar extendArr = line.replace( extendRe, '' ).split( ',' )\n\n\t// if any item in the list is not a placeholder, fail\n\tplaceholder = extendArr.every( function( line ) {\n\t\tvar trimmed = line.trim()\n\t\treturn trimmed.substr( 0, 1 ) === '$'\n\t} )\n\n\tif ( this.state.conf === 'always' && placeholder === false ) {\n\t\tthis.msg( 'always use a placeholder variable when extending' )\n\t}\n\telse if ( this.state.conf === 'never' && placeholder === true ) {\n\t\tthis.msg( 'placeholder variables are disallowed' )\n\t}\n\n\treturn placeholder\n}\n\nmodule.exports = placeholders\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/prefixVarsWithDollar.js":"'use strict'\n\nvar dollaRe = /\\$[\\-_]*\\w/\nvar eqEndRe = /=$|=\\s$/\nvar ignoreRe = /(\\[.+\\])|if|for|else|return|@require|@import|@media|@block|vendor-prefixes|calc|(=|= )$|{$/ // 3\n\n\n/**\n * @description check that $ is used when declaring vars\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if in order, false if not\n */\nvar prefixVarsWithDollar = function( line ) {\n\tif ( this.state.hashOrCSS || ignoreRe.test( line ) ) { return }\n\n\tvar hasDolla = true\n\n\t// if line has a mixin, we need check each param for missing $\n\t// else we just check if = is present && $ is prefixing something\n\tif ( this.state.conf === 'always' ) {\n\t\tif ( line.indexOf( '=' ) !== -1 &&\n\t\t\tline.indexOf( '@block' ) === -1 &&\n\t\t\t!eqEndRe.test( line ) ) {\n\n\t\t\tif ( !dollaRe.test( line ) ) {\n\t\t\t\thasDolla = false\n\t\t\t}\n\t\t}\n\t}\n\t// the never check is easier, since any $ means it fails\n\telse if ( this.state.conf === 'never' && !dollaRe.test( line ) ) {\n\t\thasDolla = false\n\t}\n\n\tif ( this.state.conf === 'always' && hasDolla === false ) {\n\t\tthis.msg( 'variables and parameters must be prefixed with the $ sign', 0 )\n\t}\n\telse if ( this.state.conf === 'never' && hasDolla === true ) {\n\t\tthis.msg( '$ sign is disallowed for variables and parameters', 0 )\n\t}\n\n\treturn hasDolla\n}\n\nmodule.exports = prefixVarsWithDollar\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/quotePref.js":"'use strict'\n\nvar stringRe = /(?=[\"'])(?:\"[^\"\\\\]*(?:\\\\[\\s\\S][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\s\\S][^'\\\\]*)*')/g\n\n\n/**\n * @description check that quote style is consistent with config\n * @param  {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @return {boolean} true if in order, false if not\n */\nvar quotePref = function( line, origLine ) {\n\tif ( origLine.indexOf( '\"' ) === -1 &&\n\t\t\torigLine.indexOf( \"'\" ) === -1 ) {\n\t\treturn\n\t}\n\n\tstringRe.lastIndex = 0\n\n\tvar badQuotes = false\n\tvar hasInnerQuote = true\n\tvar match\n\n\t// for each quote match, check err\n\twhile ( ( match = stringRe.exec( origLine ) ) !== null ) {\n\t\t// just checks the first inner quote, most common case\n\t\t// almost certainly not the best way to do this\n\t\tvar content = match[0].slice( 1, -1 )\n\n\t\t// if '' quotes preferred and match starts with double \"\" quote\n\t\tif ( this.state.conf === 'single' && match[0].indexOf( '\"' ) === 0 ) {\n\t\t\t// \"\" is allowed when it's cases like \"Someone's string here\"\n\t\t\thasInnerQuote = content.indexOf( \"'\" ) !== -1\n\n\t\t\tif ( !hasInnerQuote ) {\n\t\t\t\tbadQuotes = true\n\t\t\t\tthis.msg( 'preferred quote style is ' + this.state.conf + ' quotes', match[0].indexOf( '\"' ) )\n\t\t\t}\n\t\t}\n\t\t// if \"\" quotes preferred and match start with single '' quote\n\t\telse if ( this.state.conf === 'double' && match[0].indexOf( \"'\" ) === 0 ) {\n\t\t\t// \"\" is allowed when it's cases like \"Someone's string here\"\n\t\t\thasInnerQuote = content.indexOf( '\"' ) !== -1\n\n\t\t\tif ( !hasInnerQuote ) {\n\t\t\t\tbadQuotes = true\n\t\t\t\tthis.msg( 'preferred quote style is ' + this.state.conf + ' quotes', match[0].indexOf( \"'\" ) )\n\t\t\t}\n\t\t}\n\t}\n\n\treturn badQuotes\n}\n\nmodule.exports = quotePref\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/semicolons.js":"'use strict'\n\n// we only want to check semicolons on properties/values\nvar ignoreRe = /(^[*#.])|[&>/]|{|}|if|for(?!\\w)|else|@block|@media|(}|{|=|,)$/igm\n\n\n/**\n * @description check that selector properties are sorted accordingly\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if in order, false if not\n */\nvar semicolons = function( line ) {\n\tif ( ignoreRe.test( line.trim() ) ) return\n\tif ( this.state.hashOrCss ) return\n\n\tvar semicolon\n\tvar index = line.indexOf( ';' )\n\n\tif ( this.state.conf === 'never' && index !== -1 ) {\n\t\tsemicolon = true\n\t}\n\n\t// for reasons that perplex me, even when the first use\n\t// of this at the top returns true, sometimes the method\n\t// still runs, so we add this second ignoreCheck here to catch it\n\tif ( this.state.conf === 'always' && !ignoreRe.test( line.trim() ) ) {\n\t\tif ( index === -1 &&\n\t\t\tline.indexOf( '}' ) === -1 &&\n\t\t\tline.indexOf( '{' ) === -1 ) {\n\t\t\tsemicolon = false\n\t\t}\n\t}\n\n\tif ( this.state.conf === 'never' && semicolon === true ) {\n\t\tthis.msg( 'unnecessary semicolon found', index )\n\t}\n\telse if ( this.state.conf === 'always' && semicolon === false ) {\n\t\tthis.msg( 'missing semicolon', line.length )\n\t}\n\n\treturn semicolon\n}\n\nmodule.exports = semicolons\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/sortOrder.js":"'use strict'\n\nvar resetOnFileChange = 0\nvar ignoreMeRe = /[.#${}=>&*]|\\(.*\\)|(&:)|(if)|(for)|(@block)|(@import)|(@media)|(@extends)|,$/\nvar ordering = require( '../data/ordering.json' )\n\n\n/**\n * @description check that selector properties are sorted accordingly\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if in order, false if not\n */\nvar sortOrder = function( line ) {\n\t// we don't alphabetize the root yet\n\tif ( this.state.context === 0 || this.state.hash ) {\n\t\tthis.cache.sortOrderCache = []\n\t\treturn\n\t}\n\n\t/*\n\t * 1 we strip out mixins, and whitespace, and get the line as an array\n\t * 2 we need a sorted array to compare our cache against\n\t * 3 equals the custom sorting array via the config (or the ordering json)\n\t * 4 assume sorted by default\n\t * 5 alphabetical by default, if custom array we output a shorter msg\n\t */\n\tvar arr = this.splitAndStrip(\n\t\tnew RegExp( /[\\s\\t,:]/ ), line.replace( /(\\(.+\\))/, '' )\n\t) // 1\n\tvar sortedArr = [] // 2\n\tvar orderingArr = [] // 3\n\tvar sorted = true // 4\n\tvar orderName = this.state.conf // 5\n\n\tif ( ignoreMeRe.test( arr[0] ) ) return\n\n\tif ( Array.isArray( this.state.conf ) ) {\n\t\torderName = 'custom grouped'\n\t}\n\n\t// if current context switched, reset array\n\tif ( this.state.context !== this.state.prevContext ) {\n\t\tthis.cache.sortOrderCache = []\n\t}\n\n\t// reset on file change\n\tif ( this.cache.file !== resetOnFileChange ) {\n\t\tthis.cache.sortOrderCache = []\n\t\tresetOnFileChange = this.cache.file\n\t}\n\n\t// then we push the latest property to the cache\n\tthis.cache.sortOrderCache.push( arr[0] )\n\n\t// create a copy of the cache now for comparison against\n\tsortedArr = this.cache.sortOrderCache.slice( 0 )\n\n\t// and then sort it (by default alphabetically)\n\tif ( this.state.conf === 'alphabetical' ) {\n\t\tsortedArr = sortedArr.sort()\n\t}\n\t// if not default, we can either use the grouped option\n\t// or a custom sorting order, specificed by a config file\n\telse if ( this.state.conf === 'grouped' || Array.isArray( this.state.conf ) ) {\n\t\t// use custom ordering if specified, or fall back to in-built grouped ordering\n\t\torderingArr = Array.isArray( this.state.conf ) ? this.state.conf : ordering.grouped\n\n\t\t// iterate over our cache copy, and sort it according to our config\n\t\tsortedArr = sortedArr.sort( function( a, b ) {\n\t\t\tvar aIndex = orderingArr.indexOf( a )\n\t\t\tvar bIndex = orderingArr.indexOf( b )\n\n\t\t\t// allow properties that don't exist in ordering array to be last\n\t\t\tif ( bIndex < 0 ) {\n\t\t\t\tbIndex = orderingArr.length\n\t\t\t}\n\n\t\t\t// -1 if our 'sorted (not yet sorted)' array is not in the right order\n\t\t\tif ( aIndex < bIndex ) {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\t// and 1 if it is\n\t\t\telse if ( bIndex < aIndex ) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t} )\n\t}\n\n\t// now compare our two arrays\n\t// one sorted according to the config, and one as appears in the file\n\tif ( this.state.context === this.state.prevContext ) {\n\t\t// compare each value individually\n\t\tthis.cache.sortOrderCache.forEach( function( val, i ) {\n\t\t\t// if any value doesn't match quit the forEach\n\t\t\tif ( sortedArr[i] !== this.cache.sortOrderCache[i] ) {\n\t\t\t\tsorted = false\n\t\t\t\treturn\n\t\t\t}\n\t\t}.bind( this ) )\n\t}\n\n\tif ( sorted === false ) {\n\t\tthis.msg( 'prefer ' + orderName + ' when sorting properties' )\n\t}\n\n\treturn sorted\n}\n\nmodule.exports = sortOrder\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/stackedProperties.js":"'use strict'\n\n// if semicolons on line, but not ending the line, prolly a one-liner\nvar semiTest = /;+(?!$)/gm\n\n\n/**\n * @description disallow one-liners\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if one-liner found, false if not\n */\nvar stackedProperties = function( line ) {\n\tvar oneLiner = false\n\tvar trimmedLine = line.replace( /(( '.*')|( \".*\")|('.*')|(\".*\"))+;*/, '' ).trim()\n\tvar arr = this.splitAndStrip( ';', trimmedLine )\n\n\tif ( semiTest.test( trimmedLine ) || arr.length > 1 ) {\n\t\toneLiner = true\n\t}\n\n\tif ( this.state.conf === 'never' && oneLiner === true ) {\n\t\tthis.msg( 'avoid one liners. put properties on their own line' )\n\t}\n\n\treturn oneLiner\n}\n\nmodule.exports = stackedProperties\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/trailingWhitespace.js":"'use strict'\n\n// check for unnecessary tabs or whitespace at eol\nvar whitespaceRe = /[ \\t]+$/\n// anything BUT whitespace (we dont want to return false positives on empty lines)\nvar anythingElseRe = /[^ \\t]/\n\n/**\n * @description check for trailing whitespace\n * @param  {string} [line] curr line being linted\n * @param {string} [origLine] curr line before being stripped\n * @return {boolean} true if whitespace found, false if not\n */\nvar trailingWhitespace = function( line, origLine ) {\n\tvar whitespace = false\n\tvar hasWhitespace = whitespaceRe.exec( origLine )\n\n\t// not an empty line, with whitespace at the end\n\tif ( anythingElseRe.test( origLine ) && hasWhitespace ) {\n\t\twhitespace = true\n\t}\n\n\tif ( this.state.conf === 'never' && whitespace ) {\n\t\tthis.msg( 'trailing whitespace', hasWhitespace.index )\n\t}\n\n\treturn whitespace\n}\n\nmodule.exports = trailingWhitespace\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/universal.js":"'use strict'\n\n// checks if * is a valid use case or not\nvar universalRe = /( |\\w|\\d|'|\"|\\*|\\/)(\\*)( |\\w|\\d|'|\"|\\*|\\$|\\=)/\n\n/**\n* @description check for * selector\n* @param {string} [line] current line being linted\n* @returns {boolean} true if * on line, false if not\n*/\nvar universal = function( line ) {\n\tvar index = line.indexOf( '*' )\n\tif ( index === -1 ) return\n\n\tvar hasUniversal = false\n\n\tif ( !universalRe.test( line ) ) {\n\t\thasUniversal = true\n\t}\n\n\tif ( this.state.conf === 'never' && hasUniversal === true ) {\n\t\tthis.msg( '* selector is disallowed', index )\n\t}\n\n\treturn hasUniversal\n}\n\nmodule.exports = universal\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/valid.js":"'use strict'\n\n// 1 grab attribute selectors OR mixins that are by themselves\n// 2 strip attr selectors or classes/ids from elements\n// 3 ignore syntax\n// 4 ignore numbers\n// 5 ( from || to ) are only valid inside @keyframe\n// 6 the actual JSON property whitelist we will test against\n// 7 if interpolated value just give it a pass\nvar attrOrMixinRe = /^\\[\\S+\\]|({[\\S]+})|(\\([\\S ]+\\))|(\\(\\))/ // 1\nvar stripRe = /(?=\\S)\\[\\S+\\]|(\\.|#)(\\w|-)+/ // /(?=\\S)\\[\\S+\\]/ // 2\nvar ignoreRe = /^[$.#]|[&=>+~]|if|for|else|return|@block|calc|@extend|@media/ // 3\nvar numRe = /\\d+?(?=px|%|em|rem|v(h|w)|v(min|max)|ex|ch|mm|cm|in|pt|pc|mozmm)/ // 4\nvar keyRe = /((from)|(to))+(?= $| {| \\d|\\n|{)/ // 5\nvar validJSON = require( '../data/valid.json' ) // 6\nvar interpolatedRe = /( *{\\S+} *)/ // 7\n\n\n/**\n* @description check against a JSON of all valid css properties and values\n* @param {string} [line] current line being linted\n* @returns {boolean | undefined} true if problem, false if no prob, undefined if we skipped\n*/\nmodule.exports = function valid( line ) {\n\t// from and to are valid keyframes properties, but not outside that context\n\tif ( !this.state.keyframes && line.match( keyRe ) ) { return }\n\n\t// 1 split by tabs and spaces, tabs mess with pattern matching\n\tvar isValid = false\n\tvar arr = this.splitAndStrip( new RegExp( /[\\s\\t,:]/ ), line ) // 1\n\n\t// if not splittable for some reason\n\tif ( typeof arr[0] === 'undefined' ) return\n\n\t// in order, let line be considered valid if:\n\t// 1 we are in a hash or css block or root block\n\t// 2 classname, varname, id, or syntax.\n\t// 3 if the selector only consists of an attr or mixin (which can be custom)\n\t// 4 if it's a number\n\tif ( this.state.hashOrCSS || // 1\n\t\tthis.state.root || // 1\n\t\tinterpolatedRe.test( this.cache.origLine ) ||\n\t\tignoreRe.test( line.trim() ) || // 2\n\t\tattrOrMixinRe.test( line ) || // 3\n\t\tnumRe.test( arr[0] ) ) { // 3\n\t\tisValid = true\n\t}\n\n\t// if using an attr selector ( div[madeUpAttribute] ), strip it out ( div )\n\tif ( !isValid ) {\n\t\tarr[0] = arr[0].replace( stripRe, '' ).trim()\n\t}\n\n\t// if no match yet, check for css && prefix + css, will return true at first match\n\tif ( !isValid ) {\n\t\tisValid = validJSON.css.some( function( css ) {\n\t\t\treturn arr[0] === css || this.checkPrefix( arr[0], css, validJSON )\n\t\t}.bind( this ) )\n\t}\n\n\t// if no match yet, try html && html + pseudo\n\tif ( !isValid ) {\n\t\tisValid = validJSON.html.some( function( html ) {\n\t\t\treturn arr[0] === html || this.checkPseudo( arr[0], html, validJSON )\n\t\t}.bind( this ) )\n\t}\n\n\t// if no match yet, try pseudo as standalone\n\tif ( !isValid ) {\n\t\tisValid = validJSON.pseudo.some( function( pseudo ) {\n\t\t\t// psuedo selectors could have one of two colons\n\t\t\treturn ':' + arr[0] === pseudo || '::' + arr[0] === pseudo\n\t\t} )\n\t}\n\n\t// if no match yet, try declared mixins and custom properties\n\tif ( !isValid ) {\n\t\tisValid = this.cache.customProperties.some( function( mixin ) {\n\t\t\treturn arr[0] === mixin\n\t\t} )\n\t}\n\n\tif ( isValid === false ) {\n\t\tthis.msg( 'property is not valid', line.indexOf( arr[0] ) )\n\t}\n\n\treturn isValid\n}\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/zeroUnits.js":"'use strict'\n\nvar aboveZeroRe = /\\d0/\nvar hasUnitRe = /[ :]0+?(?=px|%|em|rem|v(h|w)|v(min|max)|ex|ch|mm|cm|in|pt|pc|mozmm)/\nvar relativeValRe = /line-height|font-size|font-weight/\n\n\n/**\n* @description check for 0unit\n* @param {string} [line] current line being linted\n* @returns {boolean | undefined} true if has units, else false, undefined if skipped\n*/\nvar zeroUnits = function( line ) {\n\t// if in keyframes dont check\n\t// if no 0 on line dont check\n\t// if relative values like font-weight, dont check\n\tif ( this.state.keyframes ||\n\t\tline.indexOf( '0' ) === -1 ||\n\t\trelativeValRe.test( line ) ) {\n\t\treturn\n\t}\n\n\tvar isCorrect = true\n\tvar always = this.state.conf === 'always'\n\tvar never = this.state.conf === 'never'\n\tvar hasUnit = hasUnitRe.exec( line )\n\tvar aboveZero = aboveZeroRe.exec( line )\n\n\t// if config set to never and 0 is followed by any unit\n\tif ( never && hasUnit ) {\n\t\tisCorrect = false\n\t}\n\t// if config set to always, we need to do an extra check\n\t// to avoid throwing false positions on numbers like 50px\n\telse if ( always && ( !hasUnit && !aboveZero ) ) {\n\t\tisCorrect = false\n\t}\n\n\tif ( never && isCorrect === false ) {\n\t\tthis.msg( '0 is preferred. Unit value is unnecessary', hasUnit.index )\n\t}\n\telse if ( always && isCorrect === false ) {\n\t\tthis.msg( 'Including the unit value is preferred' )\n\t}\n\n\treturn isCorrect\n}\n\nmodule.exports = zeroUnits\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/checks/zIndexNormalize.js":"'use strict'\n\n\n/**\n* @description check for z-index values that aren't normalized\n* @param {string} [line] current line being linted\n* @returns {boolean} true if not normalized, false if normalized\n*/\nvar zIndexNormalize = function( line ) {\n\tvar badZIndex = false\n\tvar arr = this.splitAndStrip( new RegExp( /[\\s\\t,:]/ ), line )\n\tvar index = line.indexOf( 'z-index' )\n\n\t// ignore 0 or -1 values\n\tif ( arr[ arr.length - 1 ] === '-1' ||\n\t\tarr[ arr.length - 1 ] === '0' ) {\n\t\treturn\n\t}\n\n\tif ( index !== -1 && arr[ arr.length - 1 ] % this.state.conf ) {\n\t\tbadZIndex = true\n\t}\n\n\tif ( badZIndex === true ) {\n\t\tthis.msg( 'this z-index value is not normalized', index )\n\t}\n\n\treturn badZIndex\n}\n\nmodule.exports = zIndexNormalize\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/cache.js":"var path = require( 'path' )\n\n// the main cache object\nvar cache = {\n\tcol: null, // column number for warning if applicable\n\tcomment: '', // the current line comment on the line, if there is one\n\tcustomProperties: [], // an array of all declared mixins OR custom properties\n\terrs: [], // array of errors detected so far\n\tfile: '', // curr filename we're testing\n\tfiles: [], // all files as an arr\n\tfilesLen: 0, // # of files we're testing\n\tfileNo: 0, // curr # of filesLen we're on\n\tline: '', // curr line we're testing\n\tlineNo: 0, // curr line number we're testing\n\tmsg: '', // the done message (55 warnings blah blah)\n\tmessages: [], // array of message objects, containing all data needed to output\n\torigLine: '', // original line before stripping/trimming\n\tprevFile: '', // the previous file\n\tprevFileNo: 0, // prev file no\n\tprevLine: '', // the previous line\n\trule: '', // rule name for current check\n\tsCache: { '0': [] }, // each key is an array of selectors in that context\n\tsortOrderCache: [], // we keep a context based arr of selectors here to check sort orde\n\twarnings: [], // array of the errors detected so far\n\tzCache: [] // array of z-index uses\n}\n\nmodule.exports = cache\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/config.js":"/**\n * default configuration object\n * this is what the linter will run when no config file is passed\n */\nvar config = {\n\t// check for @block when defining blocks\n\tblocks: false,\n\t// check for { or }, unless used in a hash\n\tbrackets: 'never',\n\t// enforce or disallow colons\n\tcolons: 'always',\n\t// check for hex colors used without variables\n\tcolors: 'always',\n\t// check for spaces after commas (0, 0, 0, .18)\n\tcommaSpace: 'always',\n\t// check for space after line comment\n\tcommentSpace: 'always',\n\t// if never disallow css literals\n\tcssLiteral: 'never',\n\t// set a maximum selector depth (dont nest more than 4 deep)\n\tdepthLimit: false,\n\t// check if properties or selectors are duplicate\n\tduplicates: true,\n\t// check for margin 0 0 0 0 and recommend margin 0\n\tefficient: 'always',\n\t// prefer a specific syntax when using @extends (or @extend)\n\textendPref: false,\n\t// throw duplicate selector warning across all files instead of curr file\n\tglobalDupe: false,\n\t// group reporter output by file or go sequentially\n\tgroupOutputByFile: true,\n\t// manipulate terminal output with or without an additional reporter\n\treporterOptions: {\n\t\tcolumns: ['lineData', 'severity', 'description', 'rule'],\n\t\tcolumnSplitter: '  ',\n\t\tshowHeaders: false,\n\t\ttruncate: true\n\t},\n\t// how many spaces should we prefer when indenting, pass in false if hard tabs\n\tindentPref: false,\n\t// enforce or disallow leading zeroes\n\tleadingZero: 'never',\n\t// exit if over error limit\n\tmaxErrors: false,\n\t// exit if over warning limit\n\tmaxWarnings: false,\n\t// check for mixed spaces and tabs\n\tmixed: false,\n\t// lowercase-dash, camelCase, lowercase_underscore, BEM or false (dont check)\n\tnamingConvention: false,\n\t// if true, then check classes and ids, if false just check variables\n\tnamingConventionStrict: false,\n\t// check for use of border none or outline none, prefer 0\n\tnone: 'never',\n\t// disallow !importants\n\tnoImportant: true,\n\t// check for extra space inside parens\n\tparenSpace: false,\n\t// only allow @extending of placeholder vars\n\tplaceholders: 'always',\n\t// check for $ when declaring vars (doesnt check use)\n\tprefixVarsWithDollar: 'always',\n\t// single or double quotes, or false to not check\n\tquotePref: false,\n\t// default reporter\n\treporter: '../core/reporter',\n\t// disallow or enforce semicolons\n\tsemicolons: 'never',\n\t// alphabetical, grouped, Array<String> or false (no check)\n\tsortOrder: 'alphabetical',\n\t// no one liners\n\tstackedProperties: 'never',\n\t// check for trailing whitespace\n\ttrailingWhitespace: 'never',\n\t// check for use of * and recommend against it\n\tuniversal: false,\n\t// check if prop or value is a valid assignment\n\tvalid: true,\n\t// check for use of 0px | 0em | 0rem | 0% | etc and recommend 0 instead\n\tzeroUnits: 'never',\n\t// suggest a normalized z index value, base of whatever this is\n\tzIndexNormalize: false\n}\n\nmodule.exports = config\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/done.js":"'use strict'\n\nvar columnify = require( 'columnify' )\n\nfunction getExitCode( errsLength, warningsLength, maxErrors, maxWarnings ) {\n\tif ( errsLength > 0 ) {\n\t\tif ( typeof maxErrors === 'number' ) {\n\t\t\tif ( errsLength > maxErrors ) return 1\n\t\t}\n\t\telse return 1\n\t}\n\n\tif ( typeof maxWarnings === 'number' && warningsLength > maxWarnings ) return 1\n\n\treturn 0\n}\n\n/**\n * @description outputs our messages, wipes errs/warnings if watching\n * @returns {Object | Function} returns process exit if not watching, or obj otherwise\n */\nvar done = function() {\n\tvar warningsOrErrors = []\n\tvar msg = ''\n\tvar groupedByFile = {}\n\tvar msgGrouped\n\tvar group = this.config.groupOutputByFile\n\tvar opts = this.config.reporterOptions || {}\n\n\tthis.state.exitCode = getExitCode( this.cache.errs.length, this.cache.warnings.length, this.config.maxErrors, this.config.maxWarnings )\n\n\t// when testing we want to silence the console a bit, so we have the quiet option\n\tif ( !this.state.quiet ) {\n\t\twarningsOrErrors = [].concat( this.cache.errs, this.cache.warnings )\n\t\t\t.filter( function( str ) { return !!str } )\n\n\t\t// by default group warnings and errs by file\n\t\tif ( group && this.cache.messages ) {\n\t\t\tthis.cache.messages.forEach( function( output ) {\n\t\t\t\tvar file = output.file\n\n\t\t\t\tif ( groupedByFile.hasOwnProperty( file ) ) {\n\t\t\t\t\tgroupedByFile[file].push( output )\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgroupedByFile[file] = [output]\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// iterate over arrays of message objects\n\t\t\t// each array consists of all the errors and warnings for a file\n\t\t\t// columnify the errors/warnings and prefix them with the file name\n\t\t\tmsgGrouped = Object.keys( groupedByFile ).map( function( key ) {\n\t\t\t\treturn key + '\\n' + columnify( groupedByFile[key], opts ) + '\\n\\n'\n\t\t\t} )\n\t\t}\n\n\t\tif ( warningsOrErrors.length ) {\n\t\t\tif ( group ) {\n\t\t\t\tmsg += msgGrouped\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmsg = warningsOrErrors.join( '\\n\\n' ) + '\\n\\n'\n\t\t\t}\n\t\t}\n\n\t\tmsg += this.cache.msg\n\n\t\tif ( msg ) {\n\t\t\tconsole.log( msg )\n\t\t}\n\t}\n\n\t// don't kill the linter if watch is watching\n\t// else there's no more to do, so exit the process\n\tif ( !this.state.watching ) {\n\t\tthis.callback( this.state.exitCode || null )\n\t\treturn process.exit( this.state.exitCode )\n\t}\n\n\tvar returnValue = {\n\t\terrs: this.cache.errs.slice( 0 ),\n\t\twarnings: this.cache.warnings.slice( 0 ),\n\t\texitCode: this.state.exitCode,\n\t\tmsg: this.cache.msg\n\t}\n\n\t// if watching we reset the errors/warnings arrays\n\tthis.cache.errs = []\n\tthis.cache.warnings = []\n\n\treturn returnValue\n}\n\nmodule.exports = done\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/init.js":"'use strict'\n\nvar defaults = require( 'lodash.defaults' )\n\nvar defaultOptions = {\n\twatch: false,\n\tconfig: null,\n\tstrict: false,\n\tcallback: function() {}\n}\n\n/**\n * @description initialization function, does routing and kicks it all off\n * @param {Object} [options] options passed to stylint\n * @param {String} [pathPassed] path to files to lint\n * @return {Function} always returns a function, determined by cli flags\n */\nvar init = function( options, pathPassed ) {\n\toptions = defaults( options || {}, defaultOptions )\n\n\tthis.config = this.setConfig( options.config )\n\n\t// if you want to use transparent mixins, pass in an array of them\n\t// this also covers the (more common probably) custom property use case\n\tthis.cache.customProperties = this.config.mixins || this.config.customProperties || this.cache.customProperties\n\n\t// we do the check here just in case\n\t// they don't pass in a reporter when using a custom config\n\tif ( options.reporter ) {\n\t\tthis.reporter = require( options.reporter )\n\t}\n\telse if ( this.config.reporter ) {\n\t\tthis.reporter = require( this.config.reporter )\n\t}\n\telse {\n\t\tthis.reporter = require( './reporter' )\n\t}\n\n\t// if path/ passed in use that for the dir\n\tthis.state.path = pathPassed || this.state.path || process.cwd()\n\tthis.callback = this.callback || options.callback\n\n\t// fire watch or read based on flag\n\tif ( options.watch ) {\n\t\treturn this.watch()\n\t}\n\n\treturn this.read()\n}\n\nmodule.exports = init\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/lint.js":"'use strict'\n\n\n/**\n * @description runs tests according to config ( or all if strict is true )\n * @return {Function | undefined} undefined if just calling the method, function is linting over\n */\nvar lint = function() {\n\tvar method = ''\n\tvar checks = Object.getPrototypeOf( this ).lintMethods\n\tvar maxErrs = typeof this.config.maxErrors === 'number' ? this.config.maxErrors : false\n\tvar maxWarnings = typeof this.config.maxWarnings === 'number' ? this.config.maxWarnings : false\n\n\tfor ( method in checks ) {\n\t\tif ( checks.hasOwnProperty( method ) ) {\n\t\t\tif ( this.config[method] ) {\n\t\t\t\t// save config rule name for use in reporters\n\t\t\t\tthis.cache.rule = method\n\t\t\t\t// state.conf === 'always' || 'never' || etc\n\t\t\t\tthis.state.conf = this.config[method].expect || this.config[method]\n\t\t\t\t// state.severity === 'error' || 'warning'\n\t\t\t\tthis.state.severity = this.config[method].error ? 'Error' : 'Warning'\n\t\t\t\t// run the actual check against the line\n\t\t\t\tchecks[method].call( this, this.cache.line, this.cache.origLine )\n\t\t\t\t// if check puts us over either limit, kill stylint\n\t\t\t\tif ( maxErrs &&\n\t\t\t\t\tthis.cache.errs.length > this.config.maxErrors ) {\n\t\t\t\t\treturn this.reporter( '', 'done', 'kill' )\n\t\t\t\t}\n\t\t\t\tif ( maxWarnings &&\n\t\t\t\t\tthis.cache.warnings.length > this.config.maxWarnings ) {\n\t\t\t\t\treturn this.reporter( '', 'done', 'kill' )\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// save our curr context so we can use it next time\n\t// this.cache.prevFile = this.cache.file\n\tthis.cache.prevLine = this.cache.line\n}\n\nmodule.exports = lint\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/parse.js":"'use strict'\n\n// strips out block comments and urls\nvar cleanFileRe = /(\\r\\n|\\n|\\r)|(^(\\/\\*)|([\\s'\"](\\/\\*)))(?!\\/)(.|[\\r\\n]|\\n)+?\\*\\/\\n?/gm\nvar lineEndingsRe = /\\r\\n|\\n|\\r/gm\n\n\n/**\n * @description parses file for testing by removing extra new lines and block comments\n * @param {Object} [err] error obj from async if it exists\n * @param {Array} [res] array of files to parse\n * @returns {Function} test function\n */\nvar parse = function( err, res ) {\n\tif ( err ) { throw new Error( err ) }\n\n\treturn res.forEach( function( file, i ) {\n\t\tvar lines\n\t\tthis.cache.file = this.cache.files[i]\n\t\tthis.cache.fileNo = i\n\n\t\t// strip out block comments, but dont destroy line history\n\t\t// to do these we replace block comments with new lines\n\t\tlines = file.toString().replace( cleanFileRe, function( str ) {\n\t\t\t// WHERE IS YOUR GOD NOW\n\t\t\treturn ( new Array( str.split( lineEndingsRe ).length ) ).join( '\\n' )\n\t\t} ).split( '\\n' )\n\n\t\t// updating cache as we go, and passing to the next step\n\t\tlines.forEach( function( line, lineNo ) {\n\t\t\tthis.cache.origLine = line\n\t\t\tthis.cache.line = this.trimLine( line )\n\t\t\tthis.cache.lineNo = lineNo + 1 // line nos don't start at 0\n\t\t\tthis.cache.rule = ''\n\t\t\tthis.cache.col = null\n\t\t\treturn this.setState( line )\n\t\t}.bind( this ) )\n\n\t\t// save previous file\n\t\tthis.cache.prevFile = this.cache.file\n\n\t\t// if on the last file, call the done function to output success or error msg\n\t\tif ( this.cache.fileNo === res.length - 1 ) {\n\t\t\treturn this.reporter( '', 'done' )\n\t\t}\n\t}.bind( this ) )\n}\n\nmodule.exports = parse\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/read.js":"'use strict'\n\nvar fs = require( 'fs' )\nvar async = require( 'async' )\n\n\n/**\n * @description determines what files to read, creates an array of them, and passes it to be parsed\n * @param {string} [filepath] [option for manually passing in a filename]\n * @returns {Function} parse function\n */\nvar read = function( filepath ) {\n\t// if user passes in a glob, we forEach over them\n\t// and pass it into read() as filepath\n\tvar path = filepath || this.state.path\n\n\t// if nothing passed in, default to linting the curr dir\n\t// here we get all the files to parse first, then we pass to app.parse\n\tif ( path === process.cwd() ) {\n\t\treturn this.getFiles( this.state.path + '/**/*.styl' )\n\t}\n\n\t// if * is array, assume glob\n\tif ( path instanceof Array ) {\n\t\treturn this.getFiles( this.state.path )\n\t}\n\n\t// else we'll have either a filename or dir name to work with\n\t// if dir we use the glob logic to return an array of files to test\n\treturn fs.stat( path, function( err, stats ) {\n\t\tif ( !stats || err ) {\n\t\t\tthrow Error( 'Stylint Error: No such file or dir exists!' )\n\t\t}\n\n\t\t// if this path matches any regex in the excludes array, we ignore\n\t\tvar isExcludes = function( path ) {\n\t\t\treturn this.state.exclude.some( function( exclude ) {\n\t\t\t\tif ( typeof exclude !== 'string' ) return false\n\t\t\t\tvar excludeRegExp = new RegExp( exclude, 'm' )\n\t\t\t\treturn excludeRegExp.test( path )\n\t\t\t} )\n\t\t}.bind( this )\n\n\t\t// you shall not pass\n\t\tif ( isExcludes( path ) ) return\n\n\t\tif ( stats.isFile() ) {\n\t\t\tthis.cache.filesLen = 1\n\t\t\tthis.cache.fileNo = 1\n\t\t\tthis.cache.file = path\n\t\t\tthis.cache.files = [path]\n\t\t\treturn async.map( this.cache.files, fs.readFile, this.parse.bind( this ) )\n\t\t}\n\t\tif ( stats.isDirectory() ) {\n\t\t\treturn this.getFiles( path + '/**/*.styl' )\n\t\t}\n\t}.bind( this ) )\n}\n\nmodule.exports = read\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/reporter.js":"'use strict'\n\nvar chalk = require( 'chalk' )\n\n\n/**\n * @description format output message for console (default)\n * @param  {string} msg  error msg from one of the checks\n * @param  {string} done whether or not this is the last message to output\n * @param  {string} kill whether or not we're over one of our limits\n * @return {string | Function} either the formatted msg or done()\n */\nvar reporter = function( msg, done, kill ) {\n\tif ( done === 'done' ) {\n\t\t// total errors\n\t\tthis.cache.msg = 'Stylint: ' + this.cache.errs.length + ' Errors.'\n\t\tthis.cache.msg += this.config.maxErrors ? ' (Max Errors: ' + this.config.maxErrors + ')' : ''\n\t\t// total warnings\n\t\tthis.cache.msg += '\\nStylint: ' + this.cache.warnings.length + ' Warnings.'\n\t\tthis.cache.msg += this.config.maxWarnings ? ' (Max Warnings: ' + this.config.maxWarnings + ')' : ''\n\n\t\t// if you set a max it kills the linter\n\t\tif ( kill === 'kill' ) {\n\t\t\tthis.cache.msg += '\\nStylint: Over Error or Warning Limit.'\n\t\t}\n\t\telse if ( this.cache.errs.length === 0 &&\n\t\t\tthis.cache.warnings.length === 0 ) {\n\t\t\tthis.cache.msg = ''\n\t\t}\n\n\t\treturn this.done()\n\t}\n\n\tvar file = chalk.underline( this.cache.file )\n\tvar col = typeof this.cache.col === 'number' && this.cache.col > 0 ? this.cache.col : null\n\n\tvar severity = this.state.severity.toLowerCase()\n\tseverity = severity === 'warning' ?\n\t\tchalk.yellow( severity ) :\n\t\tchalk.red( severity )\n\n\tvar rule = chalk.grey( this.cache.rule )\n\n\t// normal error or warning messages\n\tvar defaultMessage = file + '\\n' + this.cache.lineNo + ' ' + rule + ' ' + severity + ' ' + msg\n\n\t// if column data available, output slightly different line\n\tif ( typeof this.cache.col === 'number' && this.cache.col > -1 ) {\n\t\tdefaultMessage = file + '\\n' + this.cache.lineNo + ':' + this.cache.col + ' ' + rule + ' ' + severity + ' ' + msg\n\t}\n\n\t// weird syntax highlighting issue when this is inside a ternary\n\tvar linePlusCol = this.cache.lineNo + ':' + col\n\tvar messageObj = {\n\t\tfile: file,\n\t\tlineData: col ? linePlusCol : this.cache.lineNo,\n\t\tseverity: severity,\n\t\tdescription: msg,\n\t\trule: rule\n\t}\n\n\tmessageObj[file] = true\n\tthis.cache.messages.push( messageObj )\n\n\treturn defaultMessage\n}\n\nmodule.exports = reporter\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/setState.js":"'use strict'\n\n// super simple.\n// if theres anything on the line besides whitespace, it aint empty\nvar emptyLineRe = /\\S/\n\n\n/**\n * @description sets values like context, determine whether we even run tests, etc\n * @param {string} [line] curr line being linted\n * @returns {Function | undefined} undefined if we catch something, else lint()\n */\nvar setState = function( line ) {\n\tthis.state.context = this.setContext( this.cache.line )\n\n\t// ignore the current line if @stylint ignore\n\tif ( this.cache.origLine.indexOf( '@stylint ignore' ) !== -1 ) {\n\t\treturn\n\t}\n\n\t// if @stylint on / off commands found in the code\n\tif ( this.stylintOn( this.cache.origLine ) ||\n\t\tthis.stylintOff( this.cache.origLine ) === false ) {\n\t\treturn\n\t}\n\n\t// if hash starting / ending, set state and return early\n\tif ( this.hashOrCSSStart( line ) ||\n\t\tthis.hashOrCSSEnd( line ) === false ) {\n\t\treturn\n\t}\n\n\t// if starting / ending keyframes\n\tif ( this.keyframesStart( line ) ||\n\t\tthis.keyframesEnd( line ) === false ) {\n\t\treturn\n\t}\n\n\t// if starting / ending css4 :root\n\t// we'll need to capture custom properties\n\tif ( this.rootStart( line ) ||\n\t\tthis.rootEnd( line ) === false ) {\n\t\treturn\n\t}\n\n\t// if entire line is comment, just check comment spacing and that's it\n\tif ( this.startsWithComment( line ) ) {\n\t\tif ( typeof this.config.commentSpace !== 'undefined' ) {\n\t\t\tthis.state.conf = this.config.commentSpace.expect || this.config.commentSpace\n\t\t\tthis.state.severity = this.config.commentSpace.error ? 'Error' : 'Warning'\n\t\t\tthis.lintMethods.commentSpace.call( this, this.cache.line, this.cache.origLine )\n\t\t}\n\t\treturn\n\t}\n\n\t// if empty line\n\tif ( emptyLineRe.test( line ) === false ) {\n\t\tthis.cache.sortOrderCache = []\n\t\treturn\n\t}\n\n\t// actually run tests if we made it this far\n\tif ( this.state.testsEnabled === true ) {\n\t\treturn this.lint()\n\t}\n}\n\nmodule.exports = setState\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/state.js":"/**\n * @description i hold the state\n * @return {Object} [i expose properties to the entire app]\n */\nvar state = {\n\tconf: false, // config for currently running check ('always' || 'never' || etc)\n\tcontext: 0, // what is our level of nesting?\n\texclude: [], // what files should be excluded\n\texitCode: 0, // err or no err\n\thasComment: false, // checks for // in a line\n\thashOrCSS: false, // are we in a hash\n\tkeyframes: false, // are we in @keyframes\n\tkillSwitch: false, // are we over our warning limit\n\topenBracket: false, // is there an unclosed bracket\n\tpath: '', // curr dir || file\n\tprevContext: 0, // save the last context as well\n\troot: false, // css4 root block, for declaring css4 variables\n\tseverity: 'warning', // severity level for current check\n\ttestsEnabled: true, // are we running linter tests\n\tquiet: false, // turn off console logs\n\twatching: false // are we watching\n}\n\nmodule.exports = state\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/core/watch.js":"'use strict'\n\nvar chokidar = require( 'chokidar' )\n\n/**\n * @description kicks off the app. sets up config and kicks off reading the files\n * @return {Function} kick off linter on each change\n */\nvar watch = function() {\n\tthis.watcher = chokidar.watch( this.state.path )\n\n\t// initial watch msg\n\tthis.watcher.on( 'ready', function() {\n\t\tthis.state.watching = true\n\t\treturn console.log( 'Watching: ', this.state.path, ' for changes.' )\n\t}.bind( this ) )\n\n\t// listen for changes, update 'dir' to curr file, wipe all the caches, do somethin\n\tthis.watcher.on( 'change', this.resetOnChange.bind( this ) )\n}\n\nmodule.exports = watch\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/hashOrCSSEnd.js":"'use strict'\n\n\n/**\n * @description check for end ofhash or @css block\n * @param {string} [line] curr line being linted\n * @returns {boolean} false if hash or css ending, true if not\n */\nvar hashEnd = function( line ) {\n\tif ( !this.state.hashOrCSS ) { return }\n\n\t// ex }, but only if we've already establish that we're in a hash'\n\tif ( line.indexOf( '}' ) !== -1 ) {\n\t\tthis.state.hashOrCSS = false\n\t\tthis.state.testsEnabled = true\n\t}\n\n\treturn this.state.hashOrCSS\n}\n\nmodule.exports = hashEnd\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/hashOrCSSStart.js":"'use strict'\n\nvar hashStartRe = /{$|{ $|(= {)/\nvar stripMixinsRe = /(\\(.*\\))/\n\n\n/**\n * @description check for start of hash or @css block\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if hash or @css starting, false if not\n */\nvar hashStart = function( line ) {\n\tif ( this.state.hashOrCSS || !this.state.testsEnabled ) { return }\n\tvar strippedLine = line.replace( stripMixinsRe, '' )\n\n\t// ex $colorsHash = { or @css {\n\tif ( !this.config.cssLiteral && line.indexOf( '@css' ) !== -1 ||\n\t\thashStartRe.test( strippedLine ) && strippedLine.indexOf( '=' ) !== -1 ) {\n\t\tthis.state.hashOrCSS = true\n\t\tthis.state.testsEnabled = false\n\t}\n\n\t// for hash one liners (ex: $hash = { foo: 'bar' } )\n\tif ( this.state.hashOrCSS && line.indexOf( '}' ) !== -1 ) {\n\t\tthis.state.hashOrCSS = false\n\t\tthis.state.testsEnabled = true\n\t}\n\n\treturn this.state.hashOrCSS\n}\n\nmodule.exports = hashStart\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/keyframesEnd.js":"'use strict'\n\n\n/**\n * @description check for keyframes end\n * @returns {boolean} false if keyframes ending, true if not\n */\nvar keyframesEnd = function() {\n\tif ( !this.state.keyframes ) { return }\n\n\tif ( this.state.keyframes && this.state.context === 0 ) {\n\t\tthis.state.keyframes = false\n\t}\n\n\treturn this.state.keyframes\n}\n\nmodule.exports = keyframesEnd\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/keyframesStart.js":"'use strict'\n\nvar keyframeRe = /@(?:-(?:[\\w\\d]+-)*)?keyframes/\n\n/**\n * @description check for keyframes, which have some special rules\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if keyframes starting, false if not\n */\nvar keyframesStart = function( line ) {\n\tif ( this.state.keyframes || !this.state.testsEnabled ) { return }\n\n\tif ( keyframeRe.test( line ) ) {\n\t\tthis.state.keyframes = true\n\t}\n\n\treturn this.state.keyframes\n}\n\nmodule.exports = keyframesStart\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/rootEnd.js":"'use strict'\n\n\n/**\n * @description check for keyframes end\n * @returns {boolean} false if keyframes ending, true if not\n */\nvar rootEnd = function() {\n\tif ( !this.state.root ) { return }\n\n\tif ( this.state.root && this.state.context === 0 ) {\n\t\tthis.state.root = false\n\t}\n\n\treturn this.state.root\n}\n\nmodule.exports = rootEnd\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/rootStart.js":"'use strict'\n\n/**\n * @description check for keyframes, which have some special rules\n * @param {string} [line] curr line being linted\n * @returns {boolean} true if keyframes starting, false if not\n */\nvar rootStart = function( line ) {\n\tif ( this.state.root || !this.state.testsEnabled ) { return }\n\n\tif ( line.indexOf( ':root' ) !== -1 ) {\n\t\tthis.state.root = true\n\t}\n\n\treturn this.state.root\n}\n\nmodule.exports = rootStart\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/startsWithComment.js":"'use strict'\n\nvar commentRe = /(^\\/\\/)/\n\n/**\n * @description check if line starts with comment\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if comment found, false if not\n */\nvar startsWithComment = function( line ) {\n\tvar starts = false\n\n\t// ex }, but only if we've already establish that we're not in a hash\n\tif ( line.indexOf( '//' ) !== -1 &&\n\t\tcommentRe.test( line.trim() ) ) {\n\t\tstarts = true\n\t}\n\n\treturn starts\n}\n\nmodule.exports = startsWithComment\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/stylintOff.js":"'use strict'\n\n\n/**\n * @description toggle stylint off\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if stylint on, false if not\n */\nvar stylintOff = function( line ) {\n\tif ( !this.state.testsEnabled ) { return }\n\n\t// ex: $hash = { is ok but .class = { is not\n\tif ( line.indexOf( '@stylint off' ) !== -1 ) {\n\t\tthis.state.testsEnabled = false\n\t}\n\n\treturn this.state.testsEnabled\n}\n\nmodule.exports = stylintOff\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/state/stylintOn.js":"'use strict'\n\n\n/**\n * @description toggle stylint back on\n * @param  {string} [line] curr line being linted\n * @return {boolean} true if stylint on, false if not\n */\nvar stylintOn = function( line ) {\n\tif ( this.state.testsEnabled ) { return }\n\n\t// ex: $hash = { is ok but .class = { is not\n\tif ( line.indexOf( '@stylint on' ) !== -1 ) {\n\t\tthis.state.testsEnabled = true\n\t}\n\n\treturn this.state.testsEnabled\n}\n\nmodule.exports = stylintOn\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/checkPrefix.js":"'use strict'\n\n/**\n * @description used in conjunction with the valid check (for valid css)\n * @param {string} [prop] the property to prepend prefixes to\n * @param {string} [css] the css key we're checking against (from valid.json)\n * @param {Object} [valid] the valid.json object\n * @returns {boolean} true if at least one match found, false if not\n*/\nvar checkPrefix = function( prop, css, valid ) {\n\treturn valid.prefixes.some( function( prefix ) {\n\t\treturn prop === prefix + css\n\t} )\n}\n\nmodule.exports = checkPrefix\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/checkPseudo.js":"'use strict'\n\n/**\n * @description used in conjunction with the valid check (for valid html)\n * @param {string} [prop] the property to prepend prefixes to\n * @param {string} [html] the html we're checking against (from valid.json)\n * @param {Object} [valid] the valid.json object\n * @returns {boolean} true if at least one match found, false if not\n*/\nvar checkPseudo = function( prop, html, valid ) {\n\treturn valid.pseudo.some( function( pseudo ) {\n\t\treturn prop === html + pseudo\n\t} )\n}\n\nmodule.exports = checkPseudo\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/getFiles.js":"'use strict'\n\nvar fs = require( 'fs' )\nvar glob = require( 'glob' )\nvar async = require( 'async' )\nvar path = require( 'path' )\n\n/**\n * @description globs files and returns an array, used in various methods\n * @param {string} [dir] directory of files to glob\n * @returns {Array} returns an array of files\n*/\nvar getFiles = function( dir ) {\n\tif ( typeof dir !== 'string' && !( dir instanceof Array ) ) {\n\t\tthrow new TypeError( 'getFiles err. Expected string or array, but received: ' + typeof dir )\n\t}\n\n\tif ( typeof dir === 'string' ) {\n\t\treturn glob( dir, {}, function( err, files ) {\n\t\t\tif ( err ) { throw err }\n\n\t\t\tfiles = files.filter( function( file ) {\n\t\t\t\tvar excluded = false\n\t\t\t\tvar relPath = path.relative( dir.replace( '/**/*.styl', '' ), file )\n\n\t\t\t\tthis.config.exclude.forEach( function( exclude ) {\n\t\t\t\t\texcluded = excluded || exclude.match( relPath )\n\t\t\t\t} )\n\n\t\t\t\treturn !excluded\n\t\t\t}, this )\n\n\t\t\tthis.cache.filesLen = files.length - 1\n\t\t\tthis.cache.files = files\n\n\t\t\treturn async.map( this.cache.files, fs.readFile, this.parse.bind( this ) )\n\t\t}.bind( this ) )\n\t}\n\telse if ( dir instanceof Array ) {\n\n\t\tvar files = dir.filter( function( filepath ) {\n\t\t\tvar excluded = false\n\n\t\t\tthis.config.exclude.forEach( function( exclude ) {\n\t\t\t\texcluded = excluded || exclude.match( filepath )\n\t\t\t} )\n\n\t\t\treturn !excluded\n\t\t}, this )\n\n\t\tthis.cache.filesLen = files.length - 1\n\t\tthis.cache.files = files\n\t\treturn this.cache.files.forEach( function( file ) {\n\t\t\treturn this.read( file )\n\t\t}.bind( this ) )\n\t}\n}\n\nmodule.exports = getFiles\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/msg.js":"'use strict'\n\n\n/**\n * @description basically just sets the severity and routes output to the reporter\n * @param {string} [str] outputted string from one of the checks\n * @param {number} [column] column number if applicable to the check\n * @returns {Function} push formatted output to appropriate array\n*/\nvar msg = function( str, column ) {\n\t// determine which group the msg belongs to\n\tvar arr = this.state.severity === 'Warning' ? this.cache.warnings : this.cache.errs\n\tthis.cache.col = column\n\n\t// push the final output\n\treturn arr.push( this.reporter( str ) )\n}\n\nmodule.exports = msg\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/resetOnChange.js":"'use strict'\n\n/**\n * @description brittle function that just resets a bunch of caches when watch is running\n * @param {string} [newPath] if touching a new file, lint it\n * @returns {Function} kick off linter again\n*/\nvar resetOnChange = function( newPath ) {\n\tthis.state.path = newPath ? newPath : this.state.path\n\tthis.cache.errs = []\n\tthis.cache.warnings = []\n\tthis.cache.alphaCache = []\n\tthis.cache.rootCache = []\n\tthis.cache.zCache = []\n\tthis.cache.prevLine = ''\n\tthis.cache.prevFile = ''\n\tthis.cache.prevContext = 0\n\tthis.cache.sCache = {}\n\tthis.cache.sortOrderCache = []\n\n\tif ( this.state.watching ) {\n\t\treturn this.read()\n\t}\n}\n\nmodule.exports = resetOnChange\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/setConfig.js":"'use strict'\n\nvar fs = require( 'fs' )\nvar path = require( 'path' )\nvar userHome = require( 'user-home' )\nvar pathIsAbsolute = require( 'path-is-absolute' )\nvar stripJsonComments = require( 'strip-json-comments' )\nvar Glob = require( 'glob' ).Glob\n\n// @TODO i just this sloppy just to fix some stuff\n// comes back and refactor / cleanup\n\n/**\n * @description overrides default config with a new config object\n *              many potential code paths here.\n * 1: user passed in config object via function param\n * 2: user passes location of .stylintrc file to use via cli\n * 3: user has options obj in package.json or path to\n * 4: none of the above, fallback to initial config\n * 5: user has a .stylintrc file in a dir but doesnt pass anything\n * @param {String} [configpath] If defined, the path to a config-file to read\n * @returns {Function} kick off linter again\n*/\nvar setConfig = function( configpath ) {\n\tvar files = []\n\tvar customPath = ''\n\t// return default config if nothing passed in or found\n\tvar returnConfig\n\tvar cwd = process.cwd()\n\tvar pkg = null\n\ttry {\n\t\tpkg = require( cwd + '/package.json' )\n\t}\n\tcatch ( err ) {\n\t\t// no output\n\t}\n\n\t/**\n\t * @description sets the return config if one if found\n\t * @param  {string} path [where to look for config]\n\t * @return {Object|void} [object if stylintrc found, undefined if not]\n\t */\n\tvar _parseConfig = function( path ) {\n\t\treturn JSON.parse(\n\t\t\tstripJsonComments(\n\t\t\t\tfs.readFileSync( path, 'utf-8' )\n\t\t\t)\n\t\t)\n\t}\n\n\t/**\n\t * @description [reverse walk from cwd to usr]\n\t *              [if .stylintrc found, use it]\n\t * @param  {Array<string>} files [all files for this dir level]\n\t * @param  {number} level [# of dirs traversed so far]\n\t * @param  {string} cwd   [relative path to current directory being walked]\n\t * @return {?Object|?Function} [config if found, recurse if not. null if failed]\n\t */\n\tvar _recurseDirectories = function( files, level, cwd ) {\n\t\t// parse stylintrc if found, stop recursion\n\t\tif ( files.indexOf( '.stylintrc' ) !== -1 ) {\n\t\t\treturn _parseConfig( cwd + '/.stylintrc' )\n\t\t}\n\n\t\t// only go up to user home directory, stop recursion\n\t\tif ( userHome ) return null\n\n\t\t// next dir level\n\t\tvar nextLevel = level + 1\n\t\t// pathArr is generated by applying our dir level\n\t\t// to cwd, and going backwards\n\t\t// ie, level = 1, pathArr = [ cwd, '..' ]\n\t\t// ie, level = 2, pathArr = [ cwd, '..', '..' ]\n\t\t// and so on\n\t\tvar pathArr = [ cwd ]\n\n\t\t// push '..' for each dir level\n\t\twhile ( level-- ) {\n\t\t\tpathArr.push( '..' )\n\t\t}\n\n\t\t// creates the path to the next directory\n\t\tvar newPath = path.join.apply( null, pathArr )\n\t\t// gets the files for the next directory\n\t\tvar newFiles = fs.readdirSync( newPath )\n\t\t// passes the newFiles, nextLevel, and newPath to itself\n\t\t// to start the process over again\n\t\treturn _recurseDirectories( newFiles, nextLevel, newPath )\n\t}\n\n\t// if 1, the customConfig will be what we want\n\t// this only occurs if using stylint programmatically\n\t// ie, user passed in option object\n\tif ( this.customConfig ) {\n\t\treturnConfig = this.customConfig\n\t}\n\t// if 2, we pass in a path to the config\n\t// this only occurs if using stylint via the command line\n\telse if ( configpath ) {\n\t\tcustomPath = pathIsAbsolute( configpath ) ? configpath : cwd + '/' + configpath\n\t\ttry {\n\t\t\treturnConfig = _parseConfig( customPath )\n\t\t}\n\t\tcatch ( err ) {\n\t\t\tthrow err\n\t\t}\n\t}\n\t// 3, if user did not pass in option obj, or pass options via cli\n\t// check the user's package.json for either an option obj, or\n\t// at least a path to one\n\telse if ( pkg !== null &&\n\t\ttypeof pkg.stylintrc !== 'undefined' ) {\n\t\tvar rc = pkg.stylintrc\n\n\t\tif ( typeof rc === 'object' && !( rc instanceof Array ) ) {\n\t\t\treturnConfig = rc\n\t\t}\n\t\telse if ( typeof rc === 'string' ) {\n\t\t\treturnConfig = _parseConfig( rc )\n\t\t}\n\t}\n\t// 4, nothing passed in via cli or programmatically or via pkg\n\t// start at cwd, walk up to user home directory, if nothing\n\t// found, then just use the default config\n\telse {\n\t\ttry {\n\t\t\t// recurse up to user home\n\t\t\tfiles = fs.readdirSync( cwd )\n\t\t\t// null if .stylintrc file found anywhere\n\t\t\treturnConfig = _recurseDirectories( files, 1, cwd )\n\n\t\t\t// default config if nothing found\n\t\t\tif ( !returnConfig ) {\n\t\t\t\treturnConfig = this.config\n\t\t\t}\n\t\t}\n\t\t// in case there's an issue parsing or no .stylintrc found at specified location\n\t\tcatch ( err ) {\n\t\t\tthrow err\n\t\t}\n\t}\n\n\treturnConfig.exclude = ( returnConfig.exclude || [] ).map( function( exclude ) {\n\t\treturn new Glob( exclude, {\n\t\t\tmatchBase: true\n\t\t} ).minimatch\n\t} )\n\n\t// make sure indentPref is set no matter what\n\treturnConfig.indentPref = returnConfig.indentPref || false\n\n\t// 5, just return the default config if nothing found\n\treturn returnConfig\n}\n\nmodule.exports = setConfig\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/setContext.js":"'use strict'\n\n/**\n * @description whitespace is the 1 tru god of stylus, set context based on that\n * @param {string} [line] curr line being linted\n * @returns {number} # of indents deep we are\n*/\nvar setContext = function( line ) {\n\tvar context = 0\n\tvar indentPref = this.config.indentPref.expect || this.config.indentPref\n\n\tthis.state.prevContext = this.state.context\n\n\t// no matter what our indentPref is,\n\t// try to get context as best as possible\n\n\t// get context if tabs\n\tif ( line.charAt( 0 ) === '\\t' ) {\n\t\tcontext = /^\\t+/.exec( line )[0].length\n\t}\n\t// get context if spaces\n\telse if ( line.charAt( 0 ) === ' ' ) {\n\t\t// set default if no indentPref set\n\t\tif ( typeof indentPref !== 'number' ) {\n\t\t\tindentPref = 2\n\t\t}\n\n\t\tcontext = /^\\s+/.exec( line )[0].length / indentPref\n\t}\n\n\treturn context\n}\n\nmodule.exports = setContext\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/splitAndStrip.js":"'use strict'\n\n/**\n * @description alliteration. split a str according to re, and filter out empty indexes\n * @param {Object} [re] regex object for splitting\n * @param {string} [line] curr line being linted\n * @returns {Array} split and filtered array\n*/\nvar splitAndStrip = function( re, line ) {\n\treturn line.split( re ).filter( function( str ) {\n\t\treturn str.length > 0\n\t} )\n}\n\nmodule.exports = splitAndStrip\n","/home/travis/build/npmtest/node-npmtest-stylint/node_modules/stylint/src/utils/trimLine.js":"'use strict'\n\nvar urlOrContentRe = /([\"'].+[\"'])|( +|:)url\\(.+\\)/\n\n/**\n * @description separate out line comments\n *              strip out interpolation\n *              strip out url and content strings\n * @param {string} [line] curr line being linted\n * @returns {string} the line, but minus all the annoying stuff\n*/\nvar trimLine = function( line ) {\n\tvar startsWithCommentRe = /(^\\/\\/)/\n\n\t// reset values from previous line\n\tthis.state.hasComment = false\n\tthis.cache.comment = ''\n\n\t// remove urls, content strings\n\tvar noUrl = line.replace( urlOrContentRe, ' ' )\n\n\t// strip line comments, if any exist after stripping urls\n\tif ( noUrl.indexOf( '//' ) !== -1 ) {\n\n\t\t// a for real line comment, no http:// false positive\n\t\tthis.state.hasComment = true\n\t\t// separate out line comment for spacing check\n\t\tthis.cache.comment = noUrl.slice( noUrl.indexOf( '//' ), noUrl.length )\n\n\t\t// if this line comment is at the end of the line\n\t\tif ( !startsWithCommentRe.test( noUrl.trim() ) ) {\n\t\t\tnoUrl = noUrl.slice( 0, noUrl.indexOf( '//' ) - 1 )\n\t\t}\n\t}\n\n\t// strip interpolated variables\n\treturn noUrl.replace( /( *{ *\\S+ *} *)/, '' )\n}\n\nmodule.exports = trimLine\n"}